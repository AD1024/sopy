from pydantic import Field, BaseModel
from sopy import Procedure, handler, End, make_prompt, Prompt, SOP
from sopy.prompt import cond
from sopy.interface.strands import StrandsAgent
from sopy.utils import Log
from sopy.prompt.prompt_generator import make_prompt_from_procedure
from events import *
from file_sys_sim import *

class FSInfo(BaseModel):
    src_path: str = Field(..., description="The source path from which files are to be migrated.")
    dst_path: str = Field(..., description="The destination path to which files are to be migrated.")
    backup_path: str = Field(..., description="The backup path where files are temporarily stored during migration.")
    path_read: set[str] = Field(default_factory=set, description="Set of paths that have been read from the source directory.")
    path_copied: set[str] = Field(default_factory=set, description="Set of paths that have been copied to the destination directory.")
    path_backuped: set[str] = Field(default_factory=set, description="Set of paths that have been backed up to the backup directory.")
    files_in_backup: set[str] = Field(default_factory=set, description="Set of files that have been backed up to the backup directory.")
    files_in_migration: set[str] = Field(default_factory=set, description="Set of files that have been migrated to the destination directory.")


"""
An SOP that provides the atomic file migration operations. The following prompt is generated by sopy
from the state machine:

Procedure ReadDir:
    Instruction: Read the directory to be migrated Then proceed to BackUpCopy.
    Action: eReadDirectory
Procedure BackUpCopy:
    Instruction: For each file in the directory, copy it to the given backup location. If retry limit is reached, then go to Abort. If all files copied to backup location, then go to MigrateCopy.
    Action: eFileCopied, eCopyRequest
Procedure MigrateCopy:
    Instruction: For each file in the directory, copy it to the migrate location. If retry limit is reached, then go to Abort. If all files copied to the migration location, then go to Clear.
    Action: eFileCopied, eCopyRequest
Procedure Abort:
    Instruction: Delete all copied backup files and migrated files (if any), and abort the procedure. If backups and partially migrated files are deleted, then finish the procedure, and report related results to the user.
    Action: eFileDeleted, eFileDeleteRequest
Procedure Clear:
    Instruction: Delete the backup files and the original files (not the original directory) and finish the procedure. If all files deleted from backup location, then finish the procedure, and report related results to the user.
    Action: eFileDeleted, eFileDeleteRequest
"""

class ReadDir(Procedure[FSInfo]):
    prompt = make_prompt("Read the directory to be migrated")

    @handler
    def handle_eReadDirectory(self, sigma: FSInfo, event: eReadDirectory):
        if event.payload[1] is None:
            return f"Failed to read directory {event.payload[0]}. Please check the path and try again."
        sigma.path_read |= set((f'{event.payload[0]}/{filename}' for filename in event.payload[1]))
        sigma.src_path = event.payload[0]
        Log.info(f"Directory read {sigma.src_path} with files: {" | ".join(sigma.path_read)}")
        return BackUpCopy(prompt=make_prompt("For each file in the directory, copy it to the given backup location."))

class Copy(Procedure[FSInfo]):

    def __init__(self, prompt: Prompt):
        self.prompt = prompt
        self.copied = set()
        self.srcs = set()
        self.kv = dict()
        self.retry = 2

    @handler
    def handle_eCopyRequest(self, sigma: FSInfo, event: eCopyRequest):
        if cond(self.retry == 0, "retry limit is reached"):
            return Abort()
        src, dst = event.payload
        assert src.startswith(sigma.src_path), f"Source {src} is not from the source path {sigma.src_path}."
        assert src in sigma.path_read, f"Source {src} not in read paths."
        assert dst not in self.copied, f"File {dst} already exists in this backup operation for {self.kv[dst]}."
        assert src not in self.srcs, f"File {src} already copied in this backup operation."
        return self

class BackUpCopy(Copy):
    @handler
    def handle_eFileCopied(self, sigma: FSInfo, event: eFileCopied):
        if event.payload is None:
            self.retry -= 1
            return self
        src, dst = event.payload
        assert dst.startswith(sigma.backup_path), f"Destination {dst} is not from the backup path {sigma.backup_path}. You should copy to the backup first before copying to elsewhere."
        self.copied.add(src)
        self.kv[dst] = src
        sigma.path_backuped.add(src)
        sigma.files_in_backup.add(dst)
        Log.info(f"Current path_backuped: {sigma.path_backuped}, copied files: {self.copied}, kv: {self.kv}")
        if cond(sigma.path_read == sigma.path_backuped,
                "all files copied to backup location"):
            return MigrateCopy(prompt=make_prompt("For each file in the directory, copy it to the migrate location."))
        return self

class MigrateCopy(Copy):
    @handler
    def handle_eFileCopied(self, sigma: FSInfo, event: eFileCopied):
        if event.payload is None:
            self.retry -= 1
            return self
        src, dst = event.payload
        self.copied.add(src)
        self.kv[dst] = src
        sigma.files_in_migration.add(dst)
        Log.info(f"Current files_in_migration: {sigma.files_in_migration}, copied files: {self.copied}")
        if cond(sigma.path_read == self.copied, "all files copied to the migration location"):
            return Clear()
        return self

class Clear(Procedure[FSInfo]):
    prompt = make_prompt("Delete the backup files and the original files (not the original directory) and finish the procedure.")

    def __init__(self):
        self.deleted = set()

    @handler
    def handle_eFileDeleteRequest(self, sigma: FSInfo, event: eFileDeleteRequest):
        dst = event.payload
        assert dst not in self.deleted, f"File {dst} already deleted in this backup operation."
        assert dst in sigma.files_in_backup or dst in sigma.path_read, f"File {dst} not in backup files. Cannot delete."
        return self

    @handler
    def handle_eFileDeleted(self, sigma: FSInfo, event: eFileDeleted):
        dst = event.payload
        if dst is None:
            return f"Failed to delete file {dst}. Please try again."
        sigma.files_in_backup.discard(dst)
        sigma.path_read.discard(dst)
        if cond(len(sigma.files_in_backup) == 0 and len(sigma.path_read) == 0,
                "all files deleted from backup location"):
            return End()
        return self
        
class Abort(Procedure[FSInfo]):
    prompt = make_prompt("Delete all copied backup files and migrated files (if any), and abort the procedure")

    def __init__(self):
        self.deleted_backup = set()
        self.deleted_migration = set()

    @handler
    def handle_eFileDeleteRequest(self, sigma: FSInfo, event: eFileDeleteRequest):
        # check whether the file is from the backup path or migration path
        dst = event.payload
        if dst in sigma.files_in_backup:
            assert dst not in self.deleted_backup, f"File {dst} already deleted in the backup path."
        elif dst in sigma.files_in_migration:
            assert dst not in self.deleted_migration, f"File {dst} already deleted in the migration path."
        else:
            return f"File {dst} is not from the backup or migration path. Cannot delete."
        return self

    @handler
    def handle_eFileDeleted(self, sigma: FSInfo, event: eFileDeleted):
        dst = event.payload
        if dst is None:
            return f"Failed to delete file {dst}. Please try again."
        if dst in sigma.files_in_backup:
            self.deleted_backup.add(dst)
        elif dst in sigma.files_in_migration:
            self.deleted_migration.add(dst)
        else:
            return f"File {dst} is not from the backup or migration path. Cannot delete."
        
        if cond(self.deleted_backup == sigma.files_in_backup and self.deleted_migration == sigma.files_in_migration,
                "backups and partially migrated files are deleted"):
            return End()
        return self


class FileSystemOperator(SOP[FSInfo]):
    def __init__(self, src_path: str, dst_path: str, backup_path: str):
        """
        Initialize the SOP with the given source and destination paths.
        """
        super().__init__(
            state=FSInfo(src_path=src_path, dst_path=dst_path, backup_path=backup_path),
            init_proc=ReadDir()
        )

def start_task(src_path: str, dst_path: str, backup_path: str):
    """
    Start a file system operation task to migrate files from src_path to dst_path with backup at backup_path.
    
    Args:
        src_path (str): The source path from which files are to be migrated.
        dst_path (str): The destination path to which files are to be migrated.
        backup_path (str): The backup path where files are temporarily stored during migration.
    """
    objective = "Migrate files from source to destination with backup safety"
    sop = FileSystemOperator(src_path, dst_path, backup_path).observes(
        eReadDirectory, eFileDeleteRequest, eFileDeleted, eCopyRequest, eFileCopied
    )
    prompt = make_prompt_from_procedure(sop.init_proc, objective)
    print(prompt)
    agent = StrandsAgent(tools=[read_dir, cp, delete], system_prompt=prompt)
    sop = sop.with_recovery(
        error_handler=lambda prompt: agent(f"Error occurred: {prompt}"),
        retry_limits=3
    )

    current_files = read_dir(src_path)[1]

    with sop:
        agent(f"Move all files from {src_path} to {dst_path} with backup at {backup_path} using given tools only.")

    
    migrated_files = read_dir(dst_path)[1]
    backup_files = read_dir(backup_path)[1]
    assert migrated_files is not None and backup_files is not None
    assert migrated_files == current_files, f"Files in destination {dst_path} do not match source {src_path}. Migrated files: {migrated_files}, Source files: {current_files}"
    assert len(backup_files) == 0, f"Backup files {backup_files} should be empty after migration. Some files were not deleted."
    assert read_dir(src_path)[1] == [], f"Source directory {src_path} should be empty after migration. Remaining files: {read_dir(src_path)}"


start_task('/files', '/migrated_files', '/backups')